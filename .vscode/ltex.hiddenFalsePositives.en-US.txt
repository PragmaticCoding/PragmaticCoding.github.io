{"rule":"LITTLE_BIT","sentence":"^\\QThe \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q needs to move down the height of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q plus a little bit, and to the right to avoid the border.\\E$"}
{"rule":"DROP_DOWN","sentence":"^\\QAdditionally, the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q needs to have its width and height bound to the containing \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, with the height adjusted to account for how much it dropped down at the top to meet the middle of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThere was a lot of back and forth about the OP's strange ideas about how \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q work, but the answer posted by Sai Dandem was very good and forms the basis for what we're going to look at in this article.\\E$"}
{"rule":"SOME_OF_THE","sentence":"^\\QFinally, some of the geometry gets a bit goofy if the menu only has two or three items, and graphics tend to drift towards the centre.\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\QBut here's the thing:  Each of those \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a JavaFX object of it own.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QWe have a field for the text and graphic components of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q that will appear in the menu wedge, a functional element equivalent to a Java \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for the menu action and then an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q that will be used when the menu item is hovered over.\\E$"}
{"rule":"SOME_OF_THE","sentence":"^\\QThis is valid, but also easy to fix by creating factory methods and Kotlin extension functions that automate some of the boilerplate.\\E$"}
{"rule":"MD_BE_NON_VBP","sentence":"^\\QThe rules for determining the where a resource should be are actually quite simple\\E$"}
{"rule":"OUTSIDE_OF","sentence":"^\\QThis is useful because it can be defined at the file level, outside of any classes:\\E$"}
